# Flutter analyzer configuration for Kaiteki project
# Enforces consistent code style and quality standards

analyzer:
  errors:
    deprecated_member_use: ignore
    library_private_types_in_public_api: ignore
    sized_box_for_whitespace: ignore
    use_build_context_synchronously: ignore
  exclude:
    - build/**
    - .dart_tool/**
    - ios/**
    - android/**
    - macos/**
    - windows/**
    - linux/**
    - web/**
    - .githooks/**
    - assets/**
    - "**.g.dart"
    - "**.freezed.dart"
    - "**.mocks.dart"

include: package:flutter_lints/flutter.yaml

linter:
  rules:
    # Import standards
    # Use package imports instead of relative imports
    # Good: import 'package:kaiteki/models/user.dart';
    # Bad: import '../../models/user.dart';
    always_use_package_imports: true
    avoid_relative_lib_imports: true

    # Enforce import ordering: dart, flutter, packages, project
    # dart:* → flutter/* → package:third_party → package:kaiteki
    directives_ordering: true

    # Naming conventions
    # Classes use PascalCase: UserProfile, ScreenTimeData
    camel_case_types: true
    camel_case_extensions: true

    # Files use snake_case: user_profile.dart, screen_time_data.dart
    file_names: true

    # Variables use camelCase: userName, screenTimeLimit
    non_constant_identifier_names: true

    # Constants use camelCase with k prefix: kDefaultTimeout, kMaxRetries
    constant_identifier_names: true

    # Libraries use snake_case: library my_library;
    library_names: true
    library_prefixes: true

    # Documentation
    # Use /// for doc comments, not //
    # Good: /// Calculates user score
    # Bad: // Calculates user score
    slash_for_doc_comments: true

    # Code formatting
    # Add trailing commas for better diffs and auto-formatting
    # Good: User(name: 'John', age: 30,)
    require_trailing_commas: true

    # Use single quotes for strings
    # Good: 'Hello World'
    # Bad: "Hello World"
    prefer_single_quotes: true

    # Prefer final for local variables that don't change
    # Good: final name = user.name;
    # Bad: var name = user.name;
    prefer_final_locals: true
    prefer_final_fields: true
    prefer_final_in_for_each: true

    # Unnecessary code
    # Remove unnecessary braces in string interpolation
    # Good: 'Hello $name'
    # Bad: 'Hello ${name}'
    unnecessary_brace_in_string_interps: true

    # Remove redundant const/new keywords
    # Good: Container()
    # Bad: new Container()
    unnecessary_const: true
    unnecessary_new: true

    # Remove unnecessary null checks
    # Good: value ?? 0
    # Bad: value != null ? value : 0
    unnecessary_null_aware_assignments: true
    unnecessary_null_in_if_null_operators: true

    # Remove unnecessary method overrides that just call super
    unnecessary_overrides: true

    # Remove unnecessary parentheses, this, etc.
    unnecessary_parenthesis: true
    unnecessary_this: true
    unnecessary_string_escapes: true
    unnecessary_string_interpolations: true

    # Avoid redundant default values
    # Good: void method({int value = 0})
    # Bad: void method({int value = 0}) => method(value: 0);
    avoid_redundant_argument_values: true
    avoid_returning_null_for_void: true
    avoid_unnecessary_containers: true

    # Collections
    # Use collection literals instead of constructors
    # Good: final list = [];
    # Bad: final list = List();
    prefer_collection_literals: true

    # Use isEmpty/isNotEmpty instead of length checks
    # Good: if (list.isEmpty)
    # Bad: if (list.length == 0)
    prefer_is_empty: true
    prefer_is_not_empty: true

    # Use whereType instead of where + is checks
    # Good: list.whereType<String>()
    # Bad: list.where((e) => e is String)
    prefer_iterable_whereType: true

    # Strings
    # Concatenate adjacent strings without +
    # Good: 'Hello ' 'World'
    # Bad: 'Hello ' + 'World'
    prefer_adjacent_string_concatenation: true

    # Use interpolation instead of concatenation
    # Good: 'Hello $name'
    # Bad: 'Hello ' + name
    prefer_interpolation_to_compose_strings: true

    # Error handling
    # Use rethrow to preserve stack trace
    # Good: catch (e) { rethrow; }
    # Bad: catch (e) { throw e; }
    use_rethrow_when_possible: true

    # Async/await
    # Avoid returning void from async functions
    # Good: Future<void> method()
    # Bad: void method() async
    avoid_void_async: true

    # Cancel stream subscriptions to prevent memory leaks
    cancel_subscriptions: true
    close_sinks: true

    # Await or explicitly ignore futures
    # Good: await future; or unawaited(future);
    # Bad: future; (no await)
    unawaited_futures: true

    # Performance
    # Avoid slow async IO operations
    avoid_slow_async_io: true

    # Flutter specific
    # Put child parameter last in widgets
    # Good: Container(color: red, child: Text())
    # Bad: Container(child: Text(), color: red)
    sort_child_properties_last: true

    # Use full 8-digit hex for colors
    # Good: Color(0xFF123456)
    # Bad: Color(0x123456)
    use_full_hex_values_for_flutter_colors: true

    # Null safety
    # Don't check for null in equality operators
    # Good: bool operator ==(Object other) => other is User && id == other.id;
    avoid_null_checks_in_equality_operators: true

    # Don't pass null where closure is expected
    null_closures: true

    # Use null-aware operators
    # Good: value?.toString()
    # Bad: value == null ? null : value.toString()
    prefer_null_aware_operators: true

    # Constructors
    # Don't initialize to null (it's the default)
    # Good: String? name;
    # Bad: String? name = null;
    avoid_init_to_null: true

    # Don't mark final variables as nullable unnecessarily
    unnecessary_nullable_for_final_variable_declarations: true

    # Control flow
    # Simplify boolean expressions
    # Good: return isValid;
    # Bad: return isValid ? true : false;
    avoid_bool_literals_in_conditional_expressions: true

    # Use conditional assignment
    # Good: name ??= 'Unknown';
    # Bad: if (name == null) name = 'Unknown';
    prefer_conditional_assignment: true

    # Use ?? operator instead of null checks
    # Good: value ?? 0
    # Bad: value != null ? value : 0
    prefer_if_null_operators: true

    # Functions
    # Avoid boolean positional parameters (use named instead)
    # Good: method(enabled: true)
    # Bad: method(true)
    avoid_positional_boolean_parameters: true

    # Use Function(int) instead of typedef
    use_function_type_syntax_for_parameters: true

    # Testing
    # Ensure test types are handled in equals
    test_types_in_equals: true

    # Security
    # Don't import web libraries in Flutter apps
    avoid_web_libraries_in_flutter: true

    # Don't put logic in createState
    # Good: createState() => _MyState();
    # Bad: createState() { doSomething(); return _MyState(); }
    no_logic_in_create_state: true

    # Code organization
    # Put required named parameters first
    # Good: method({required String name, int? age})
    # Bad: method({int? age, required String name})
    always_put_required_named_parameters_first: true

    # Use logger instead of print
    avoid_print: true

    # Be consistent with deprecated annotations
    deprecated_consistency: true

    # Modern patterns
    # Use for elements instead of map + fromIterable
    # Good: [for (var x in list) x * 2]
    # Bad: list.map((x) => x * 2).toList()
    prefer_for_elements_to_map_fromIterable: true

    # Use function declarations instead of variables
    # Good: void method() {}
    # Bad: final method = () {};
    prefer_function_declarations_over_variables: true

    # Use if elements in collections
    # Good: [if (showTitle) title]
    # Bad: showTitle ? [title] : []
    prefer_if_elements_to_conditional_expressions: true

    # Use inlined adds in collections
    # Good: [...list, newItem]
    # Bad: list.add(newItem)
    prefer_inlined_adds: true

    # Use spread collections
    # Good: [...list1, ...list2]
    # Bad: list1 + list2
    prefer_spread_collections: true

    # Type annotations
    # Annotate public APIs with types
    # Good: String getName() => name;
    # Bad: getName() => name;
    type_annotate_public_apis: true

    # Avoid patterns
    # Avoid empty else blocks
    avoid_empty_else: true

    # Don't initialize fields in const constructors
    avoid_field_initializers_in_const_classes: true

    # Don't implement value types
    avoid_implementing_value_types: true

    # Avoid JS rounded int issues
    avoid_js_rounded_ints: true

    # One declaration per line
    # Good: var a = 1; var b = 2;
    # Bad: var a = 1, b = 2;
    avoid_multiple_declarations_per_line: true

    # Don't shadow type parameters
    avoid_shadowing_type_parameters: true

    # Avoid single cascades
    # Good: object.method();
    # Bad: object..method();
    avoid_single_cascade_in_expression_statements: true

    # Don't use type.toString()
    avoid_type_to_string: true

    # Don't use types as parameter names
    avoid_types_as_parameter_names: true

    # Remove unused constructor parameters
    avoid_unused_constructor_parameters: true

    # Prefer patterns
    # Put asserts in initializer lists
    prefer_asserts_in_initializer_lists: true

    # Use const constructors when possible
    prefer_const_constructors: true
    prefer_const_constructors_in_immutables: true
    prefer_const_declarations: true
    prefer_const_literals_to_create_immutables: true

    # Use contains instead of indexOf
    # Good: list.contains(item)
    # Bad: list.indexOf(item) != -1
    prefer_contains: true

    # Use generic function type aliases
    prefer_generic_function_type_aliases: true

    # Use initializing formals
    # Good: User(this.name);
    # Bad: User(String name) : name = name;
    prefer_initializing_formals: true

    # Use int literals instead of double
    # Good: const value = 1;
    # Bad: const value = 1.0;
    prefer_int_literals: true

    # Type uninitialized variables
    prefer_typing_uninitialized_variables: true

    # Use void instead of Null
    prefer_void_to_null: true

    # Miscellaneous
    # Provide deprecation messages
    # Good: @Deprecated('Use newMethod instead')
    provide_deprecation_message: true

    # Sort constructors first in classes
    sort_constructors_first: true
    sort_unnamed_constructors_first: true

    # Tighten initializing formal types
    tighten_type_of_initializing_formals: true

    # Use ColoredBox instead of Container(color:)
    use_colored_box: true

    # Use DecoratedBox instead of Container(decoration:)
    use_decorated_box: true

    # Use enums instead of classes
    use_enums: true

    # Use ?? to convert nulls to bools
    # Good: value ?? false
    # Bad: value == null ? false : value
    use_if_null_to_convert_nulls_to_bools: true

    # Use isEven instead of modulo
    # Good: number.isEven
    # Bad: number % 2 == 0
    use_is_even_rather_than_modulo: true

    # Use late for private fields
    use_late_for_private_fields_and_variables: true

    # Extract named constants
    # Good: const kTimeout = 30;
    # Bad: Magic numbers
    use_named_constants: true

    # Use raw strings for regex
    # Good: r'\d+'
    # Bad: '\\d+'
    use_raw_strings: true

    # Use StringBuffer for concatenation
    use_string_buffers: true

    # Use super parameters in constructors
    # Good: User(super.key);
    # Bad: User({Key? key}) : super(key: key);
    use_super_parameters: true

    # Use test matchers for exceptions
    # Good: expect(() => method(), throwsA(isA<Exception>()));
    use_test_throws_matchers: true

    # Use toList/toSet when appropriate
    use_to_and_as_if_applicable: true

    # Check void return types
    void_checks: true
